// Node.js script to extract sprite tile data from frogger_rom.js
// Run: node extract_sprites.js > frogger_ultra_sprites.js

import { ROM0, ROM0_2, ROM1, ROM1_2 } from './frogger_rom.js';

const bank0 = [...ROM0, ...ROM0_2];
const bank1 = [...ROM1, ...ROM1_2];

function decodeTile(idx) {
  const o = idx * 8, tile = [];
  for (let row = 0; row < 8; row++) {
    const b0 = bank0[o + row] || 0;
    const raw1 = bank1[o + row] || 0;
    const b1 = (raw1 & 0xFC) | ((raw1 & 1) << 1) | ((raw1 >> 1) & 1);
    const line = [];
    for (let bit = 7; bit >= 0; bit--) line.push(((b0 >> bit) & 1) | (((b1 >> bit) & 1) << 1));
    tile.push(line);
  }
  const rot = [];
  for (let x = 0; x < 8; x++) { const r = []; for (let y = 7; y >= 0; y--) r.push(tile[y][x]); rot.push(r); }
  return rot;
}

const TILE_INDICES = {
  frogUp:[0x72,0x70,0x73,0x71], frogLeap:[0x76,0x74,0x77,0x75],
  frogAnim1:[0x7A,0x78,0x7B,0x79], frogAnim2:[0x7E,0x7C,0x7F,0x7D], frogAnim3:[0x82,0x80,0x83,0x81],
  turtle:[0x36,0x38,0x37,0x35], turtle2:[0x3A,0x3C,0x3B,0x39], turtle3:[0x3E,0x3C,0x3F,0x3D],
  turtleDive1:[0x8A,0x88,0x8B,0x89], turtleDive3:[0x92,0x90,0x93,0x91], turtleDive4:[0x96,0x94,0x97,0x95], turtleDive5:[0x9A,0x98,0x9B,0x99],
  logL:[0x56,0x54,0x57,0x55], logM:[0x5A,0x58,0x5B,0x59], logR:[0x5E,0x5C,0x5F,0x5D],
  grass:[0x4A,0x48,0x4B,0x49],
  car1:[0x52,0x50,0x53,0x51], car2:[0x32,0x30,0x33,0x31], car3:[0xA2,0xA0,0xA3,0xA1],
  dozer:[0xA6,0xA4,0xA7,0xA5], truck:[0xAA,0xA8,0xAB,0xA9], truck2:[0xAE,0xAC,0xAF,0xAD],
  snake1:[0xB2,0xB0,0xB3,0xB1], snake2:[0xB6,0xB4,0xB7,0xB5], snake3:[0xBA,0xB8,0xBB,0xB9],
  snake4:[0xBE,0xBC,0xBF,0xBD], snake5:[0xC2,0xC0,0xC3,0xC1], snake6:[0xC6,0xC4,0xC7,0xC5],
  gator1:[0xCA,0xC8,0xCB,0xC9], gator2:[0xCE,0xCC,0xCF,0xCD], gator3:[0xD2,0xD0,0xD3,0xD1], gatorHead:[0x6A,0x68,0x6B,0x69],
  otter1:[0x9E,0x9C,0x9F,0x9D], otter2:[0xE2,0xE0,0xE3,0xE1],
  death:[0xF2,0xF0,0xF3,0xF1], squash:[0xE6,0xE4,0xE7,0xE5], squash2:[0xEA,0xE8,0xEB,0xE9], squash3:[0xEE,0xEC,0xEF,0xED],
  homeFrog:[0x6E,0x6C,0x6F,0x6D], fly:[0x2E,0x2C,0x2F,0x2D],
  lives:[0x4D], level:[0x4C],
  base40:[0x40], base41:[0x41], base42:[0x42], base43:[0x43], base44:[0x44], base45:[0x45], base46:[0x46], base47:[0x47],
};

// Decode all sprites - flatten each tile to a single 64-element array
const TILES = {};
for (const [name, indices] of Object.entries(TILE_INDICES)) {
  TILES[name] = indices.map(idx => decodeTile(idx).flat());
}

// Output sprite entries one per line
const spriteLines = Object.entries(TILES).map(([name, tiles]) => 
  `  ${name}:[${tiles.map(t => `[${t.join(',')}]`).join(',')}]`
).join(',\n');

console.log(`// Frogger Ultra - Pre-computed sprite data (generated by extract_sprites.js)

const PAL = {
  frog:['#0000','#00AA00','#00FF00','#FFFF00'],
  lady:['#0000','#AA00AA','#FF00FF','#FFAAFF'],
  car1:['#0000','#FFFF00','#FF0000','#FF00FF'],
  car2:['#0000','#00FFFF','#FFFF00','#FF00FF'],
  car3:['#0000','#FFFFFF','#FF0000','#00FF00'],
  truck:['#0000','#FFFFFF','#FF0000','#00FF00'],
  dozer:['#0000','#FFFFFF','#FF0000','#00FF00'],
  log:['#0000','#996633','#CC9966','#FFCC99'],
  turtle:['#0000','#00AA00','#00FF00','#FFFF00'],
  sink:['#0000','#CCCCCC','#666666','#00FF00'],
  death:['#0000','#FFFF00','#FF0000','#FF00FF'],
  fly:['#0000','#00FF00','#FFFF00','#FF0000'],
  snake:['#0000','#00FF00','#FFFF00','#FF00FF'],
  gator:['#0000','#996633','#CC9966','#FF0000'],
  otter:['#0000','#996633','#CC9966','#FFCC99'],
  grass:['#0000','#AA00AA','#FF00FF','#FFAAFF'],
  lives:['#0000','#00AA00','#00FF00','#FFFF00'],
};

// Pre-decoded tile data: each tile is flat 64-element array (8x8, row-major)
const TILES = {
${spriteLines}
};

const cache = new Map();

function rotateTile(t, n) {
  let r = t;
  for (let i = 0; i < (n % 4); i++) {
    const rot = [];
    for (let x = 0; x < 8; x++) for (let y = 7; y >= 0; y--) rot.push(r[y * 8 + x]);
    r = rot;
  }
  return r;
}

function renderToCanvas(tiles, colors, scale, fx, fy, rot) {
  const is2x2 = tiles.length === 4;
  const w = is2x2 ? 16 * scale : 8 * scale, h = 16 * scale;
  const c = document.createElement('canvas');
  c.width = w; c.height = h;
  const ctx = c.getContext('2d');
  if (rot) tiles = tiles.map(t => rotateTile(t, rot));
  const drawTile = (t, ox, oy) => {
    for (let i = 0; i < 64; i++) {
      const r = (i / 8) | 0, col = i % 8;
      const v = t[(fy ? 7 - r : r) * 8 + (fx ? 7 - col : col)];
      if (v) { ctx.fillStyle = colors[v]; ctx.fillRect(ox + col * scale, oy + r * scale, scale, scale); }
    }
  };
  if (is2x2) {
    let [tl,tr,bl,br] = [0,1,2,3];
    if (rot === 1) [tl,tr,bl,br] = [2,0,3,1];
    if (rot === 3) [tl,tr,bl,br] = [1,3,0,2];
    if (fx) [tl,tr,bl,br] = [tr,tl,br,bl];
    if (fy) [tl,tr,bl,br] = [bl,br,tl,tr];
    drawTile(tiles[tl], 0, 0); drawTile(tiles[tr], 8*scale, 0);
    drawTile(tiles[bl], 0, 8*scale); drawTile(tiles[br], 8*scale, 8*scale);
  } else {
    drawTile(tiles[0], 0, 0);
    if (tiles.length > 1) drawTile(tiles[1], 8*scale, 0);
  }
  return { canvas: c, w, h };
}

function getSprite(name, pal, scale, fx = false, fy = false, rot = 0) {
  const key = \`\${name}:\${pal}:\${scale}:\${fx?1:0}:\${fy?1:0}:\${rot}\`;
  if (!cache.has(key)) {
    const tiles = TILES[name];
    if (!tiles) return null;
    cache.set(key, renderToCanvas(tiles, PAL[pal] || PAL.frog, scale, fx, fy, rot));
  }
  return cache.get(key);
}

export function draw(ctx, name, pal, x, y, scale = 2, fx = false, fy = false, rot = 0) {
  const s = getSprite(name, pal, scale, fx, fy, rot);
  if (s) ctx.drawImage(s.canvas, x, y);
}

export function drawLog(ctx, x, y, width, scale = 2) {
  const segs = Math.max(2, Math.round(width / 16));
  draw(ctx, 'logL', 'log', x, y, scale);
  for (let i = 1; i < segs - 1; i++) draw(ctx, 'logM', 'log', x + i * 16 * scale, y, scale);
  if (segs > 1) draw(ctx, 'logR', 'log', x + (segs - 1) * 16 * scale, y, scale);
}

export { PAL, TILES };`);
